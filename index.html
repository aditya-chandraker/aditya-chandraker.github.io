<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="About me page" />
    <meta name="author" content="Aditya Chandraker" />
    <title>Adi</title>
    <!-- Favicon-->
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
    <link href="css/styles.css" rel="stylesheet" />
</head>

<body>
    <!-- Page Content-->
    <canvas id="myCanvas" style="position: fixed; top: 0; left: 0;"></canvas>
    <div class="text" class="display-5 fw-bold" style="background: rgb(255, 255, 255, .1); color: white;">I am Adi</div>


    <!-- Bootstrap core JS-->
    <script src="js/bootstrap.bundle.min.js"></script>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d', { powerPreference: 'high-performance' });

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        ctx.fillStyle = 'rgba(77, 0, 0, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        function startTimer(duration, display) {
            var timer = duration, minutes, seconds;
            setInterval(function () {
                minutes = parseInt(timer / 60, 10);
                seconds = parseInt(timer % 60, 10);

                minutes = minutes < 10 ? "0" + minutes : minutes;
                seconds = seconds < 10 ? "0" + seconds : seconds;

                display.textContent = minutes + ":" + seconds;

                if (--timer < 0) {
                    timer = duration;
                }
            }, 1000);
        }
        window.onload = function () {
            var minutes = 60 * 7,
                display = document.querySelector('#time');
            startTimer(minutes, display);
        };
    </script>

    <!-- canvas for 3 js -->
    <div id="container" style="position:absolute; top:0; left:0;z-index: 10; display:none" class="fade-in">
        <div class="controls mobile-only" style="z-index: 30">
            <div><button id="up">W</button></div>

            <div>
                <button id="left">A</button>
                <button id="down">S</button>
                <button id="right">D</button>
                <button id="space" style="margin-left: 30px; width: 50vw;">space</button>
            </div>
        </div>

        <div style="position:absolute; top:0; right:1vw;z-index: 20;color: white"><span id="time">07:00</span></div>
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <!-- <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script> -->

    <script type="importmap">
			{
				"imports": {
					"three": "./js/three.module.js",
					"three/addons/": "./js/jsm/"
				}
			}
		</script>

    <script type="module">

        // imports -----------------------------------------------------------------------------------
        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';

        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        import { Octree } from 'three/addons/math/Octree.js';
        import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';

        import { Capsule } from 'three/addons/math/Capsule.js';

        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // variables --------------------------------------------------------------------------------
        const clock = new THREE.Clock();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x0f0f0f, 0, 50);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.rotation.order = 'YXZ';

        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        const container = document.getElementById('container');

        const stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        // lights -----------------------------------------------------------------------------------
        const pointlights = [];

        const pointlight1 = new THREE.PointLight(0xffffff, 5, 100);
        pointlight1.position.set(-0.6, 4, 0); // xyz
        pointlights.push(pointlight1);

        const pointlight2 = new THREE.PointLight(0xffffff, 5, 100);
        pointlight2.position.set(5, 4, -6.6);
        pointlights.push(pointlight2);

        const pointlight3 = new THREE.PointLight(0xffffff, 5, 100);
        pointlight3.position.set(21, 4, -2);
        pointlights.push(pointlight3);

        const pointlight4 = new THREE.PointLight(0xffffff, 5, 100);
        pointlight4.position.set(16, 4, -12);
        pointlights.push(pointlight4);

        for (let i = 0; i < pointlights.length; i++) {
            pointlights[i].castShadow = true;
            pointlights[i].shadow.camera.near = 0.01;
            pointlights[i].shadow.camera.far = 500;
            pointlights[i].shadow.camera.right = 30;
            pointlights[i].shadow.camera.left = -30;
            pointlights[i].shadow.camera.top = 30;
            pointlights[i].shadow.camera.bottom = -30;
            pointlights[i].shadow.mapSize.width = 1024;
            pointlights[i].shadow.mapSize.height = 1024;
            pointlights[i].shadow.radius = 4;
            pointlights[i].shadow.bias = -0.00006;
            // pointlights[i].display = none;
            pointlights[i].visible = false;
            scene.add(pointlights[i]);
        }

        pointlights[0].visible = true;

        // const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // color, intensity
        // scene.add(ambientLight);


        // renderer ---------------------------------------------------------------------------------

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // THREE.VSMShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.physicallyCorrectLights = true;
        renderer.gammaFactor = 2.2;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        // balls ------------------------------------------------------------------------------------

        const GRAVITY = 50;

        const NUM_SPHERES = 100;
        const SPHERE_RADIUS = 0.2;

        const STEPS_PER_FRAME = 5;

        const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_RADIUS, 5);
        const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xbbbb44 });

        const spheres = [];
        let sphereIdx = 0;

        for (let i = 0; i < NUM_SPHERES; i++) {

            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.castShadow = true;
            sphere.receiveShadow = true;

            scene.add(sphere);

            spheres.push({
                mesh: sphere,
                collider: new THREE.Sphere(new THREE.Vector3(0, - 100, 0), SPHERE_RADIUS),
                velocity: new THREE.Vector3()
            });

        }

        const worldOctree = new Octree();

        const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);

        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();

        let playerOnFloor = false;
        let mouseTime = 0;

        const keyStates = {};

        const vector1 = new THREE.Vector3();
        const vector2 = new THREE.Vector3();
        const vector3 = new THREE.Vector3();

        function throwBall() {

            const sphere = spheres[sphereIdx];

            camera.getWorldDirection(playerDirection);

            sphere.collider.center.copy(playerCollider.end).addScaledVector(playerDirection, playerCollider.radius * 1.5);

            // throw the ball with more force if we hold the button longer, and if we move forward

            const impulse = 15 + 30 * (1 - Math.exp((mouseTime - performance.now()) * 0.001));

            sphere.velocity.copy(playerDirection).multiplyScalar(impulse);
            sphere.velocity.addScaledVector(playerVelocity, 2);

            sphereIdx = (sphereIdx + 1) % spheres.length;

        }


        // gui --------------------------------------------------------------------------------------

        document.addEventListener('keydown', (event) => {

            keyStates[event.code] = true;

        });

        document.addEventListener('keyup', (event) => {

            keyStates[event.code] = false;

        });

        document.addEventListener('click', (event) => {
            const tagName = event.target.tagName.toLowerCase();
            console.log(tagName);
            switch (tagName) {
                case 'button':
                    switch (event.target.id) {
                        case 'up':
                            playerVelocity.add(getForwardVector().multiplyScalar(5));
                            break;
                        case 'left':
                            playerVelocity.add(getSideVector().multiplyScalar(- 5));
                            break;
                        case 'down':
                            playerVelocity.add(getForwardVector().multiplyScalar(- 5));
                            break;
                        case 'right':
                            playerVelocity.add(getSideVector().multiplyScalar(5));
                            break;
                        case 'space':
                            playerVelocity.y = 30;
                            break;
                    }
                    break;
            }
        });


        container.addEventListener('mousedown', () => {

            document.body.requestPointerLock();

            mouseTime = performance.now();

        });

        document.addEventListener('mouseup', () => {

            // checks if its just a tap and if the screen is mobile
            if (document.pointerLockElement !== null && !window.matchMedia('(max-width: 767px)').matches) throwBall();

        });

        document.body.addEventListener('mousemove', (event) => {

            if (document.pointerLockElement === document.body) {

                camera.rotation.y -= event.movementX / 500;
                camera.rotation.x -= event.movementY / 500;

            }

        });


        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;

        container.addEventListener('touchstart', () => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            touchMoveX = event.touches[0].clientX;
            touchMoveY = event.touches[0].clientY;
            const deltaX = touchMoveX - touchStartX;
            const deltaY = touchMoveY - touchStartY;
            camera.rotation.y -= deltaX / 2500;
            camera.rotation.x -= deltaY / 2500;
        });

        // document.addEventListener('touchend', () => {
        //     // checks if its just a tap and if the screen is mobile
        //     if (Math.abs(touchMoveX - touchStartX) < 10 && Math.abs(touchMoveY - touchStartY) < 10 && window.matchMedia('(max-width: 767px)').matches) throwBall();
        // });

        // Resize ------------------------------------------------------------------------------------

        window.addEventListener('resize', onWindowResize);

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


        // Player Interactions -----------------------------------------------------------------------

        function playerCollisions() {

            const result = worldOctree.capsuleIntersect(playerCollider);

            playerOnFloor = false;

            if (result) {

                playerOnFloor = result.normal.y > 0;

                if (!playerOnFloor) {

                    playerVelocity.addScaledVector(result.normal, - result.normal.dot(playerVelocity));

                }

                playerCollider.translate(result.normal.multiplyScalar(result.depth));

            }

        }

        function updatePlayer(deltaTime) {

            let damping = Math.exp(- 4 * deltaTime) - 1;

            if (!playerOnFloor) {

                playerVelocity.y -= GRAVITY * deltaTime;

                // small air resistance
                damping *= 0.1;

            }

            playerVelocity.addScaledVector(playerVelocity, damping);

            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);

            playerCollisions();

            camera.position.copy(playerCollider.end);

        }

        function playerSphereCollision(sphere) {

            const center = vector1.addVectors(playerCollider.start, playerCollider.end).multiplyScalar(0.5);

            const sphere_center = sphere.collider.center;

            const r = playerCollider.radius + sphere.collider.radius;
            const r2 = r * r;

            // approximation: player = 3 spheres

            for (const point of [playerCollider.start, playerCollider.end, center]) {

                const d2 = point.distanceToSquared(sphere_center);

                if (d2 < r2) {

                    const normal = vector1.subVectors(point, sphere_center).normalize();
                    const v1 = vector2.copy(normal).multiplyScalar(normal.dot(playerVelocity));
                    const v2 = vector3.copy(normal).multiplyScalar(normal.dot(sphere.velocity));

                    playerVelocity.add(v2).sub(v1);
                    sphere.velocity.add(v1).sub(v2);

                    const d = (r - Math.sqrt(d2)) / 2;
                    sphere_center.addScaledVector(normal, - d);

                }

            }

        }

        function spheresCollisions() {

            for (let i = 0, length = spheres.length; i < length; i++) {

                const s1 = spheres[i];

                for (let j = i + 1; j < length; j++) {

                    const s2 = spheres[j];

                    const d2 = s1.collider.center.distanceToSquared(s2.collider.center);
                    const r = s1.collider.radius + s2.collider.radius;
                    const r2 = r * r;

                    if (d2 < r2) {

                        const normal = vector1.subVectors(s1.collider.center, s2.collider.center).normalize();
                        const v1 = vector2.copy(normal).multiplyScalar(normal.dot(s1.velocity));
                        const v2 = vector3.copy(normal).multiplyScalar(normal.dot(s2.velocity));

                        s1.velocity.add(v2).sub(v1);
                        s2.velocity.add(v1).sub(v2);

                        const d = (r - Math.sqrt(d2)) / 2;

                        s1.collider.center.addScaledVector(normal, d);
                        s2.collider.center.addScaledVector(normal, - d);

                    }

                }

            }

        }

        function updateSpheres(deltaTime) {

            spheres.forEach(sphere => {

                sphere.collider.center.addScaledVector(sphere.velocity, deltaTime);

                const result = worldOctree.sphereIntersect(sphere.collider);

                if (result) {

                    sphere.velocity.addScaledVector(result.normal, - result.normal.dot(sphere.velocity) * 1.5);
                    sphere.collider.center.add(result.normal.multiplyScalar(result.depth));

                } else {

                    sphere.velocity.y -= GRAVITY * deltaTime;

                }

                const damping = Math.exp(- 1.5 * deltaTime) - 1;
                sphere.velocity.addScaledVector(sphere.velocity, damping);

                playerSphereCollision(sphere);

            });

            spheresCollisions();

            for (const sphere of spheres) {

                sphere.mesh.position.copy(sphere.collider.center);

            }

        }

        // Game Physics Functions --------------------------------------------------------------------

        function getForwardVector() {

            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();

            return playerDirection;

        }

        function getSideVector() {

            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);

            return playerDirection;

        }

        function controls(deltaTime) {

            // gives a bit of air control
            const speedDelta = deltaTime * (playerOnFloor ? 25 : 8);

            if (keyStates['KeyW']) {

                playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));

            }

            if (keyStates['KeyS']) {

                playerVelocity.add(getForwardVector().multiplyScalar(- speedDelta));

            }

            if (keyStates['KeyA']) {

                playerVelocity.add(getSideVector().multiplyScalar(- speedDelta));

            }

            if (keyStates['KeyD']) {

                playerVelocity.add(getSideVector().multiplyScalar(speedDelta));

            }

            if (playerOnFloor) {

                if (keyStates['Space']) {

                    playerVelocity.y = 15;

                }

            }

        }


        function teleportPlayerIfOob() {

            if (camera.position.y <= - 25) {

                playerCollider.start.set(0, 0.35, 0);
                playerCollider.end.set(0, 1, 0);
                playerCollider.radius = 0.35;
                camera.position.copy(playerCollider.end);
                camera.rotation.set(0, 0, 0);

            }

        }

        // load the house model ----------------------------------------------------------------------

        const loader = new GLTFLoader().setPath('assets/');

        loader.load('houseNoLight.glb', (gltf) => {

            scene.add(gltf.scene);

            worldOctree.fromGraphNode(gltf.scene);

            gltf.scene.traverse(child => {

                if (child.isMesh) {

                    child.castShadow = true;
                    child.receiveShadow = true;

                    if (child.material.map) {

                        child.material.map.anisotropy = 4;

                    }

                }

                // if (child.isLight) {
                //     // child.castShadow = true;
                //     // child.shadow.camera.near = 0.01;
                //     // child.shadow.camera.far = 500;
                //     // child.shadow.camera.right = 30;
                //     // child.shadow.camera.left = - 30;
                //     // child.shadow.camera.top = 30;
                //     // child.shadow.camera.bottom = - 30;
                //     // child.shadow.mapSize.width = 1024;
                //     // child.shadow.mapSize.height = 1024;
                //     child.shadow.radius = 4;
                //     child.shadow.bias = - 0.00006;
                //     child.castShadow = true;
                //     // child.shadow.camera.near = 0.01;
                //     // child.shadow.camera.far = 500;
                //     child.shadow.camera.right = 1;
                //     child.shadow.camera.left = - 1;
                //     child.shadow.camera.top = 1;
                //     child.shadow.camera.bottom = - 1;
                //     // child.shadow.mapSize.width = 1024;
                //     // child.shadow.mapSize.height = 1024;
                //     child.shadow.bias = - 0.00006;
                //     // child.shadow.camera.updateProjectionMatrix();
                //     // child.shadow.blurSamples = 25
                // }

            });

            // const helper = new OctreeHelper(worldOctree);
            // helper.visible = false;
            // scene.add(helper);

            // const gui = new GUI({ width: 200 });
            // gui.add({ debug: false }, 'debug')
            //     .onChange(function (value) {

            //         helper.visible = value;

            //     });

            animate();

        });


        const cameraDistanceThreshold = 8; // Change this to the desired distance threshold

        function updateLights() {
            // Update the camera and other objects in the scene

            const cameraPosition = camera.position;

            for (let i = 0; i < pointlights.length; i++) {
                const pointlight = pointlights[i];
                const distance = cameraPosition.distanceTo(pointlight.position);
                pointlight.visible = distance < cameraDistanceThreshold;
            }
        }

        function animate() {

            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

            // we look for collisions in substeps to mitigate the risk of
            // an object traversing another too quickly for detection.

            for (let i = 0; i < STEPS_PER_FRAME; i++) {

                controls(deltaTime);

                updatePlayer(deltaTime);

                updateSpheres(deltaTime);

                teleportPlayerIfOob();

                updateLights()

            }

            renderer.render(scene, camera);

            stats.update();

            requestAnimationFrame(animate);

        }


        // Fade in ----------------------------------------------------------------------------------
        container.style.display = 'block';
        container.style.opacity = 0;
        const fadeIn = setInterval(() => {
            container.style.opacity = Number(container.style.opacity) + 0.1;
            if (container.style.opacity >= 1) {
                clearInterval(fadeIn);
            }
        }, 100);


    </script>


</body>

</html>